plugins {
    id 'java'
    id 'distribution'
    id 'com.bmuschko.docker-remote-api' version '6.6.1'
}
import com.bmuschko.gradle.docker.tasks.container.*

dependencies {
    implementation project(":cgi-api"), project(':plain-cgi'), project(':libfcgi-graal'), project(':html-writer')
    testImplementation "com.agorapulse:gru-http:0.8.4"
}


[
        'HelloWorldCgi': 'hello_world.cgi',
        'HelloWorldFcgi': 'hello_world.fcgi'
].each { className, scriptName ->
    task "startScript${className}"(type: CreateStartScripts) {
        description "Generate start script"
        applicationName = scriptName
        outputDir = file("build/scripts")
        mainClassName = "org.ethelred.cgi.examples.${className}"
        //https://stackoverflow.com/questions/43937169/gradle-application-plugin-with-multiple-main-classes/46938169
        classpath = project.tasks.getAt(JavaPlugin.JAR_TASK_NAME).outputs.files.plus(project.configurations.getByName(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME))
    }
}

installDist.dependsOn tasks.matching { it.name.startsWith "startScript" }

distributions {
    main {
        contents {
            from(project.tasks.getAt(JavaPlugin.JAR_TASK_NAME).outputs.files.plus(project.configurations.getByName(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME))) {
                into 'lib'
            }
            from('build/scripts') {
                into 'bin'
            }
            from(sourceSets.main.resources)
        }
    }
}

task linkWebDir(type: DockerExecContainer) {
    dependsOn ":docker:startContainer"
    targetContainerId project.containerName
    workingDir = "/app"
    withCommand("ln", "-s", "$buildDir/install/integration".replaceAll("$rootProject.projectDir", "/app"), "$apacheRoot/")
}

[
        'HelloWorldFcgi': 'hello_world.fcgi',
        'ParamsFcgi': 'params.fcgi'
].each { className, appName ->
    task "nativeImageClass$className"(type: DockerExecContainer) {
        dependsOn installDist, ":docker:startContainer", linkWebDir
        targetContainerId project.containerName
        workingDir = "/app"
        withCommand(
                [
                "native-image", "--no-fallback", "--allow-incomplete-classpath",
                "-cp", fileTree("$buildDir/install/integration/lib").asPath.replaceAll("$rootProject.projectDir", "/app"),
                "org.ethelred.cgi.examples.$className",
                "$apacheRoot/integration/native/$appName"
        ])
    }
}

task nativeImage {
    dependsOn tasks.matching { it.name.startsWith "nativeImageClass" }
}

test.dependsOn ":docker:startContainer", nativeImage